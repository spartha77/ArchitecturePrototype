#include "face_detection.h"

using namespace InferenceEngine;
using namespace std;


FaceDetection::FaceDetection(std::string model_path, string device)
{
    xml_file = model_path + "faceDetector.xml";
    bin_file = model_path + "faceDetector.bin";
    ldmk_name = "529";
    cls_name = "530";
    loc_name = "output0";
    model_path_ = model_path;
    device_ = device;
}
bool FaceDetection::initialize()
{
    // --------------------------- 1. Load Plugin for inference engine -------------------------------------
//    cout << "InferenceEngine: " << GetInferenceEngineVersion() << "\n";


    #if defined _WINDOWS
    file_name_t filename(L"");
    #else
    file_name_t filename("");
    #endif
    std::vector<file_name_t> vecFileNames = { filename };
    plugin = PluginDispatcher(vecFileNames).getPluginByDevice(device_);

    // --------------------------- 2. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
    xml_file = model_path_;
    bin_file = model_path_.substr(0, model_path_.find_last_of('.')) + ".bin";

    CNNNetReader networkReader;
    networkReader.ReadNetwork(xml_file);
    networkReader.ReadWeights(bin_file);
    CNNNetwork network = networkReader.getNetwork();
    network.setBatchSize(1);
    // --------------------------- 3. Configure input & output ---------------------------------------------
    InferenceEngine::InputsDataMap inputsInfo(network.getInputsInfo());
//    cout << "Input size: " << inputsInfo.size() << endl;

    imageInputName = inputsInfo.begin()->first;
    auto inputInfo = inputsInfo.begin()->second;
    inputInfo->setPrecision(Precision::FP32);
    inputInfo->setLayout(Layout::NCHW);
    // cout << "InputName is: " << imageInputName << endl;
    // cout << "Batch size is: " << std::to_string(networkReader.getNetwork().getBatchSize()) << endl;

    InferenceEngine::OutputsDataMap outputsInfo(network.getOutputsInfo());
//    cout << "Output size: " << outputsInfo.size() << endl;
    for (auto &item : outputsInfo)
    {
        outputNames.push_back(item.first);
        DataPtr outputData = item.second;
        outputData->setPrecision(Precision::FP32);
        const SizeVector outputDims = outputData->getTensorDesc().getDims();
        // cout << "outputName is: " << item.first << endl;
        // cout << "output dims: " << outputDims.size() << endl;
    }

    // --------------------------- 4. Loading model to the plugin ------------------------------------------
    executable_network = plugin.LoadNetwork(network, {});
    // --------------------------- 5. Create infer request -------------------------------------------------
    infer_request = executable_network.CreateInferRequest();
    return true;
}

void FaceDetection::detect(cv::Mat img, std::vector<bbox> &total_box)
{
    total_box.clear();

    float scale_x = (float)OPENVINO_DET_INPUT_WIDTH / (float)img.cols;
    float scale_y = (float)OPENVINO_DET_INPUT_HEIGHT / (float)img.rows;

//    cout << scale_x <<"  "<<scale_y<<"\n";
    cv::Mat img_scale;
    cv::resize(img, img_scale, cv::Size(OPENVINO_DET_INPUT_WIDTH, OPENVINO_DET_INPUT_HEIGHT));

    //pass data to OpenVINO
    Blob::Ptr imageInput = infer_request.GetBlob(imageInputName);
    SizeVector blobSize = imageInput.get()->getTensorDesc().getDims();
    const size_t width = blobSize[3];
    const size_t height = blobSize[2];
    const size_t channels = blobSize[1];
    std::vector<cv::Mat> input_channels;
    float *blob_data = imageInput->buffer().as<float *>();
    for (size_t i = 0; i < channels; ++i)
    {
        cv::Mat channel(height, width, CV_32FC1, blob_data);
        input_channels.push_back(channel);
        blob_data += width * height;
    }
    cv::Size input_geometry_ = cv::Size(width, height);
    cv::Mat fp_img;
    img_scale.convertTo(fp_img, CV_32FC3);
    cv::Scalar channel_mean = cv::Scalar(103.94, 116.78, 123.68);
    cv::Mat mean_ = cv::Mat(input_geometry_, CV_32FC3, channel_mean);
    cv::subtract(fp_img, mean_, fp_img);
    cv::split(fp_img, input_channels);

    //openvino infer
    infer_request.Infer();
    //process output
    const Blob::Ptr output_blob_ldmk = infer_request.GetBlob(ldmk_name);
    const Blob::Ptr output_blob_cls = infer_request.GetBlob(cls_name);
    const Blob::Ptr output_blob_loc = infer_request.GetBlob(loc_name);
    const float *ptr_ldmks = static_cast<PrecisionTrait<Precision::FP32>::value_type *>(output_blob_ldmk->buffer());
    const float *ptr_cls = static_cast<PrecisionTrait<Precision::FP32>::value_type *>(output_blob_cls->buffer());
    const float *ptr_loc = static_cast<PrecisionTrait<Precision::FP32>::value_type *>(output_blob_loc->buffer());

    std::vector<box> anchor;
    create_anchor(anchor, img_scale.cols, img_scale.rows);

    for (size_t i = 0; i < anchor.size(); ++i)
    {
        if (*(ptr_cls + 1) > DETECTION_THRESHOLD)
        {
            box tmp = anchor[i];
            box tmp1;
            bbox result;
            // loc and conf
            tmp1.cx = tmp.cx + *ptr_loc * 0.1 * tmp.sx;
            tmp1.cy = tmp.cy + *(ptr_loc + 1) * 0.1 * tmp.sy;
            tmp1.sx = tmp.sx * exp(*(ptr_loc + 2) * 0.2);
            tmp1.sy = tmp.sy * exp(*(ptr_loc + 3) * 0.2);
            result.x1 = (tmp1.cx - tmp1.sx / 2) * img_scale.cols;
            result.x1 = std::max(.0f, result.x1);
            result.y1 = (tmp1.cy - tmp1.sy / 2) * img_scale.rows;
            result.y1 = std::max(.0f, result.y1);
            result.x2 = (tmp1.cx + tmp1.sx / 2) * img_scale.cols;
            result.x2 = std::min(result.x2, (float)img_scale.cols);
            result.y2 = (tmp1.cy + tmp1.sy / 2) * img_scale.rows;
            result.y2 = std::min(result.y2, (float)img_scale.rows);
            result.s = *(ptr_cls + 1);
            // landmark
            for (int j = 0; j < 5; ++j)
            {
                result.point[j]._x = (tmp.cx + *(ptr_ldmks + (j << 1)) * 0.1 * tmp.sx) * img_scale.cols;
                result.point[j]._y = (tmp.cy + *(ptr_ldmks + (j << 1) + 1) * 0.1 * tmp.sy) * img_scale.rows;
            }

            total_box.push_back(result);
        }
        ptr_loc += 4;
        ptr_cls += 2;
        ptr_ldmks += 10;
    } //~end_for
    std::sort(total_box.begin(), total_box.end(), cmp);
    nms(total_box, DETECTION_NMS);

    for (size_t j = 0; j < total_box.size(); j++)
    {
        total_box[j].x1 /= scale_x;
        total_box[j].y1 /= scale_y;
        total_box[j].x2 /= scale_x;
        total_box[j].y2 /= scale_y;
        for (int k = 0; k < 5; k++)
        {
            total_box[j].point[k]._x /= scale_x;
            total_box[j].point[k]._y /= scale_y;
        }
    }

}

void FaceDetection::create_anchor(std::vector<box> &anchor, int w, int h)
{
    anchor.clear();
    std::vector<std::vector<int>> feature_map(4), min_sizes(4);
    float steps[] = {8, 16, 32, 64};
    for (size_t i = 0; i < feature_map.size(); ++i)
    {
        feature_map[i].push_back(ceil(h / steps[i]));
        feature_map[i].push_back(ceil(w / steps[i]));
    }
    std::vector<int> minsize1 = {10, 16, 24};
    min_sizes[0] = minsize1;
    std::vector<int> minsize2 = {32, 48};
    min_sizes[1] = minsize2;
    std::vector<int> minsize3 = {64, 96};
    min_sizes[2] = minsize3;
    std::vector<int> minsize4 = {128, 192, 256};
    min_sizes[3] = minsize4;

    for (size_t k = 0; k < feature_map.size(); ++k)
    {
        std::vector<int> min_size = min_sizes[k];
        for (int i = 0; i < feature_map[k][0]; ++i)
        {
            for (int j = 0; j < feature_map[k][1]; ++j)
            {
                for (size_t l = 0; l < min_size.size(); ++l)
                {
                    float s_kx = min_size[l] * 1.0 / w;
                    float s_ky = min_size[l] * 1.0 / h;
                    float cx = (j + 0.5) * steps[k] / w;
                    float cy = (i + 0.5) * steps[k] / h;
                    box axil = {cx, cy, s_kx, s_ky};
                    anchor.push_back(axil);
                }
            }
        }
    }
}

void FaceDetection::nms(std::vector<bbox> &input_boxes, float NMS_THRESH)
{
    std::vector<float> vArea(input_boxes.size());
    for (int i = 0; i < int(input_boxes.size()); ++i)
    {
        vArea[i] = (input_boxes.at(i).x2 - input_boxes.at(i).x1 + 1) * (input_boxes.at(i).y2 - input_boxes.at(i).y1 + 1);
    }
    for (int i = 0; i < int(input_boxes.size()); ++i)
    {
        for (int j = i + 1; j < int(input_boxes.size());)
        {
            float xx1 = std::max(input_boxes[i].x1, input_boxes[j].x1);
            float yy1 = std::max(input_boxes[i].y1, input_boxes[j].y1);
            float xx2 = std::min(input_boxes[i].x2, input_boxes[j].x2);
            float yy2 = std::min(input_boxes[i].y2, input_boxes[j].y2);
            float w = std::max(float(0), xx2 - xx1 + 1);
            float h = std::max(float(0), yy2 - yy1 + 1);
            float inter = w * h;
            float ovr = inter / (vArea[i] + vArea[j] - inter);
            if (ovr >= NMS_THRESH)
            {
                input_boxes.erase(input_boxes.begin() + j);
                vArea.erase(vArea.begin() + j);
            }
            else
            {
                j++;
            }
        }
    }
}
